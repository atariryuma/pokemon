<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ポケモンカード エディタ</title>
  <link rel="stylesheet" href="assets/z-index-vars.css">
  <style>
    :root {
      --bg: #0f1226;
      --panel: #15193a;
      --panel-2: #1c2252;
      --text: #e7ecff;
      --muted: #9fb0ff;
      --accent: #6ea8ff;
      --accent-2: #8ef6ff;
      --danger: #ff6b6b;
      --ok: #2ecc71;
      --warn: #f1c40f;
      --border: rgba(255,255,255,0.1);
      --chip: #2b3169;
      --shadow: 0 12px 32px rgba(0,0,0,.35);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", Meiryo, "Noto Sans JP", sans-serif;
      color: var(--text);
      background: radial-gradient(1200px 600px at 10% -10%, #2945b5 0%, transparent 60%),
                  radial-gradient(1200px 600px at 110% 10%, #4026a7 0%, transparent 60%),
                  var(--bg);
      overflow: hidden; /* スクロールを完全に無効 */
      font-size: 14px;
      height: 100vh; /* 高さを画面全体に固定 */
      width: 100vw; /* 幅を画面全体に固定 */
    }

    header {
      position: sticky; top: 0; z-index: 10;
      background: linear-gradient(180deg, rgba(15,18,38,.95) 0%, rgba(15,18,38,.75) 100%);
      backdrop-filter: blur(6px);
      border-bottom: 1px solid var(--border);
      padding: 10px 15px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
    }
    
    header h1 {
      flex: 1;
      min-width: 200px;
      margin: 0;
      font-size: 18px;
      letter-spacing: .5px;
    }
    
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }
    .muted { color: var(--muted); }

    .btn {
      appearance: none;
      border: 1px solid var(--border);
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
      transition: .15s ease transform, .2s ease filter, .2s ease box-shadow;
      box-shadow: 0 2px 0 rgba(0,0,0,.3) inset, 0 1px 0 rgba(255,255,255,.04) inset;
      font-weight: 600; font-size: 13px;
    }
    .btn:hover { filter: brightness(1.2); }
    .btn:active { transform: translateY(1px); }
    .btn.primary { border-color: rgba(110,168,255,.5); box-shadow: 0 0 0 1px rgba(110,168,255,.25); }
    .btn.warn { border-color: rgba(241,196,15,.5); }
    .btn.danger { border-color: rgba(255,107,107,.5); }
    .btn.ghost { background: transparent; }

    .toolbar { display: flex; gap: 8px; align-items: center; }
    .spacer { flex: 1; }
    .kbd { background: var(--chip); padding: 3px 8px; border-radius: 6px; border:1px solid var(--border); font-size: 14px; }

    .container { 
      display: grid; 
      gap: 8px; 
      padding: 8px; 
      height: calc(100vh - 60px); /* ヘッダー分を引いて固定高 */
      grid-template-columns: 1fr;
      width: 100%;
      overflow: hidden; /* コンテナ内スクロール無効 */
    }
    .panel {
      background: linear-gradient(180deg, rgba(21,25,58,.85) 0%, rgba(28,34,82,.85) 100%);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: var(--shadow);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
      height: 100%; /* パネル高さを親に合わせる */
      max-height: 100%; /* 最大高さ制限 */
    }
    .panel h2 { font-size: 16px; margin: 0; padding: 10px 12px; border-bottom: 1px solid var(--border); background: rgba(0,0,0,.15); }
    .panel .content { padding: 10px 12px; flex: 1; overflow: auto; min-height: 0; }

    .row { display: flex; gap: 8px; align-items: center; }
    .row > * { flex: 1; }
    .field { display: grid; gap: 6px; margin-bottom: 10px; }
    .field label { font-size: 13px; color: var(--muted); font-weight: 600; }
    .field input, .field select, .field textarea {
      width: 100%;
      background: rgba(0,0,0,.2);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 10px; padding: 8px 10px; font-size: 13px;
    }
    .field textarea { min-height: 70px; resize: vertical; }
    .chips { display:flex; flex-wrap: wrap; gap:6px; }
    .chip { background: var(--chip); padding: 4px 8px; border-radius: 20px; border:1px solid var(--border); font-size: 12px; }
    .hint { color: var(--muted); font-size: 14px; }

    .list-toolbar { padding: 10px; border-bottom: 1px solid var(--border); display:flex; gap:8px; align-items:center; }
    .search { flex: 1; }
    .search input { width: 100%; padding: 8px 10px; border-radius: 10px; border:1px solid var(--border); background: rgba(0,0,0,.2); color: var(--text); }

    .list { flex: 1; overflow: auto; outline: none; }
    .card-item { display:grid; grid-template-columns: auto 1fr auto; gap:10px; align-items:center; padding: 8px 10px; border-bottom:1px solid var(--border); cursor:pointer; }
    .card-item:hover { background: rgba(255,255,255,.04); }
    .card-item.active { background: rgba(110,168,255,.15); }
    .badge { padding: 3px 10px; border-radius: 16px; font-size: 13px; border:1px solid var(--border); background: rgba(255,255,255,.06); }
    .badge.pokemon { color:#ffd2d2; border-color: rgba(255,107,107,.4) }
    .badge.energy { color:#fff0b6; border-color: rgba(241,196,15,.4) }
    .badge.trainer{ color:#b8e1ff; border-color: rgba(142,246,255,.4) }
    .count { font-size: 14px; color: var(--muted); padding: 0 10px 10px; }

    .grid-2 { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    .flex-row { display:flex; gap:8px; }
    .right { text-align: right; }

    .section { margin: 8px 0 14px; padding-top: 8px; border-top:1px dashed var(--border); }
    .section h3 { font-size: 15px; margin: 0 0 8px; color: var(--muted); font-weight: 600; }

    .attacks { display: grid; gap: 8px; }
    .attack-box { border:1px solid var(--border); background: rgba(0,0,0,.15); border-radius: 10px; padding: 10px; }
    .attack-grid { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; }

    .footer { padding: 12px 16px; display:flex; gap: 8px; align-items:center; border-top:1px solid var(--border); background: rgba(0,0,0,.15); }
    .status { font-size: 14px; color: var(--muted); }

    .danger-zone { border:1px solid rgba(255,107,107,.3); background: rgba(255,107,107,.06); border-radius: 12px; padding: 10px; }
    .small { font-size: 14px; }

    .invisible { display:none; }

    /* Preview styles */
    #preview-wrap { display:flex; flex-direction: column; min-height: 0; }
    #preview-stage { position: relative; flex: 1; min-height: 260px; background: repeating-conic-gradient(#1a1f4a 0 25%, #10143a 0 50%) 50% / 18px 18px; border: 1px solid var(--border); border-radius: 10px; overflow: hidden; display:flex; align-items:center; justify-content:center; }
    #preview-img { max-width: 100%; max-height: 100%; transform-origin: center center; user-select: none; image-rendering: auto; }
    #preview-empty { position: absolute; color: var(--muted); font-size: 15px; }

    /* Drawer */
    #drawer { position: fixed; inset: 0; pointer-events: none; }
    .drawer-panel { position: absolute; top: 0; left: -420px; width: 380px; height: 100%; background: linear-gradient(180deg, rgba(21,25,58,.98) 0%, rgba(28,34,82,.98) 100%); border-right: 1px solid var(--border); box-shadow: var(--shadow); transition: left .25s ease; display:flex; flex-direction:column; pointer-events: auto; z-index: 1001; }
    .drawer-backdrop { position: absolute; inset: 0; background: rgba(0,0,0,.35); opacity: 0; transition: opacity .25s ease; z-index: 1000; }
    #drawer.open .drawer-panel { left: 0; }
    #drawer.open .drawer-backdrop { opacity: 1; pointer-events: auto; }
    #btn-open-drawer { white-space: nowrap; }

    /* Header unsaved indicator */
    header h1::after { content: var(--unsaved-dot, ""); margin-left: 8px; color: var(--warn); }
  
    /* レスポンシブメディアクエリ */
    
    /* 大画面: デスクトップ・TV (1400px以上) */
    @media (min-width: 1400px) {
      .container {
        grid-template-columns: minmax(420px, 40vw) 1fr;
        gap: 12px;
        padding: 12px;
        height: calc(100vh - 70px);
      }
      header {
        padding: 12px 20px;
      }
    }
    
    /* 中大画面: デスクトップ (1000px - 1399px) */
    @media (min-width: 1000px) and (max-width: 1399px) {
      .container {
        grid-template-columns: minmax(380px, 45vw) 1fr;
        gap: 10px;
        padding: 10px;
        height: calc(100vh - 65px);
      }
    }
    
    /* 中画面: タブレット横 (768px - 999px) */
    @media (min-width: 768px) and (max-width: 999px) {
      .container {
        grid-template-columns: minmax(320px, 50vw) 1fr;
        gap: 8px;
        padding: 8px;
        height: calc(100vh - 60px);
      }
      header {
        padding: 8px 12px;
      }
    }
    
    /* 小画面: タブレット縦・大きめスマホ (600px - 767px) */
    @media (min-width: 600px) and (max-width: 767px) {
      header {
        padding: 6px 10px;
        flex-direction: column;
        gap: 6px;
        height: 80px;
      }
      header h1 {
        text-align: center;
      }
      .container {
        grid-template-columns: 1fr;
        gap: 6px;
        padding: 6px;
        height: calc(100vh - 80px);
      }
      .grid-2 {
        grid-template-columns: 1fr;
        gap: 6px;
      }
    }
    
    /* 極小画面: スマホ (599px以下) */
    @media (max-width: 599px) {
      header {
        padding: 4px 6px;
        flex-direction: column;
        gap: 4px;
        height: 90px;
      }
      header h1 {
        text-align: center;
      }
      header h1 .muted {
        display: none;
      }
      .toolbar {
        justify-content: center;
        gap: 4px;
      }
      .container {
        grid-template-columns: 1fr;
        padding: 4px;
        gap: 4px;
        height: calc(100vh - 90px);
      }
      .panel {
        border-radius: 6px;
      }
      .panel h2 {
        padding: 6px 8px;
      }
      .field input, .field select, .field textarea {
        padding: 4px 6px;
      }
      .grid-2 {
        grid-template-columns: 1fr;
        gap: 4px;
      }
      .drawer-panel {
        width: 100vw;
        left: -100vw;
      }
      #drawer.open .drawer-panel {
        left: 0;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>ポケモンカード エディタ <span class="muted small">(cards-master.json / data/cards)</span></h1>
    <div class="toolbar">
      <button type="button" class="btn primary" id="btn-back-to-game">🎮 ゲームに戻る</button>
      <div class="spacer"></div>
      <button type="button" class="btn" id="btn-open-drawer">カード一覧 (Ctrl+K)</button>
      <button type="button" class="btn" id="btn-new-card">新規作成</button>
      <button type="button" class="btn" id="btn-open-master">master読込</button>
      <button type="button" class="btn primary" id="btn-save-master">master保存</button>
      <button type="button" class="btn" id="btn-fix-extensions">拡張子修正</button>
    </div>
  </header>

  <div class="container">
    <section class="panel" id="preview-panel">
      <h2>プレビュー</h2>
      <div class="content" id="preview-wrap">
        <div id="preview-stage">
          <img id="preview-img" alt="preview" />
          <div id="preview-empty">画像がありません。画像を選択/ドロップしてください。</div>
        </div>
        <div class="flex-row" style="align-items:center; margin-top:8px;">
          <div class="toolbar">
            <button type="button" class="btn" id="btn-zoom-out">-</button>
            <input type="range" id="zoom" min="0.5" max="3" value="1" step="0.1" title="ズーム" aria-label="ズーム" style="width:160px"/>
            <button type="button" class="btn" id="btn-zoom-in">+</button>
            <button type="button" class="btn" id="btn-fit">フィット</button>
            <button type="button" class="btn" id="btn-actual">等倍</button>
          </div>
          <div class="spacer"></div>
          <div class="toolbar">
            <button type="button" class="btn" id="btn-prev">← 前へ</button>
            <button type="button" class="btn" id="btn-next">次へ →</button>
          </div>
        </div>
      </div>
    </section>

    <section class="panel" id="editor-panel">
      <h2>カード編集</h2>
      <div class="content">
        <form id="cardForm">
          <div class="grid-2">
            <div class="field"><label for="id">ID（自動生成）</label><input id="id" required readonly title="自動生成されるID" style="background-color: rgba(0,0,0,0.3); cursor: not-allowed;" /></div>
            <div class="field"><label for="card_type">カード種別</label>
              <select id="card_type" required title="カードの種別を選択">
                <option value="Pokemon">Pokemon</option>
                <option value="Energy">Energy</option>
                <option value="Trainer">Trainer</option>
              </select>
            </div>
          </div>
          <div class="grid-2">
            <div class="field"><label for="name_en">英名 (name_en)</label><input id="name_en" required title="英語名" /></div>
            <div class="field"><label for="name_ja">和名 (name_ja)</label><input id="name_ja" required title="日本語名" /></div>
          </div>

          <div id="pokemonFields" class="section">
            <h3>ポケモン</h3>
            <div class="grid-2">
              <div class="field"><label for="stage">ステージ</label>
                <select id="stage" title="進化ステージ">
                  <option value="">-</option>
                  <option value="Basic">Basic</option>
                  <option value="Stage1">Stage1</option>
                  <option value="Stage2">Stage2</option>
                </select>
              </div>
              <div class="field"><label for="hp">HP</label><input id="hp" type="number" min="0" title="ヒットポイント" /></div>
            </div>
            <div class="grid-2">
              <div class="field"><label for="evolves_from">進化前 (evolves_from)</label><input id="evolves_from" title="進化前のポケモン名"/></div>
              <div class="field"><label for="evolves_to">進化先 (evolves_to, カンマ区切り)</label><input id="evolves_to" title="進化先のポケモン名（複数はカンマ区切り）"/></div>
            </div>
            <div class="grid-2">
              <div class="field"><label for="types">タイプ (types, カンマ区切り)</label><input id="types" placeholder="Grass, Colorless 等" title="ポケモンのタイプ（複数はカンマ区切り）"/></div>
              <div class="field"><label for="rule_box">ルールボックス</label>
                <select id="rule_box" title="ルールボックスの種類">
                  <option value="">なし</option>
                  <option value="ex">ex</option>
                  <option value="V">V</option>
                  <option value="VMAX">VMAX</option>
                </select>
              </div>
            </div>
            <div class="grid-2">
              <div class="field"><label for="weakness">弱点 (例: Lightning:x2; Fire:+)</label><input id="weakness" placeholder="type:value; type:value" title="弱点設定"/></div>
              <div class="field"><label for="resistance">抵抗力 (例: Fighting:-30)</label><input id="resistance" placeholder="type:value (1つのみ)" title="抵抗力設定"/></div>
            </div>
            <div class="grid-2">
              <div class="field"><label for="retreat_cost">にげるエネ数 (retreat_cost)</label><input id="retreat_cost" type="number" min="0" max="5" title="にげるのに必要なエネルギー数"/></div>
              <div class="field"><label for="ability_name">特性 名 (ability.name_ja / en)</label><input id="ability_name" title="特性の名前"/></div>
            </div>
            <div class="field"><label>特性 テキスト (text_ja / text_en)</label><textarea id="ability_text" placeholder="日/英はスラッシュ区切り (日本語 / English)"></textarea></div>

            <div class="section">
              <div class="flex-row" style="justify-content:space-between; align-items:center;">
                <h3>ワザ (attacks)</h3>
                <button type="button" class="btn small" id="btn-add-attack">+ 追加</button>
              </div>
              <div class="attacks" id="attacks"></div>
            </div>
          </div>

          <div id="energyFields" class="section">
            <h3>エネルギー</h3>
            <div class="field">
              <label for="energy_type">エネルギータイプ</label>
              <select id="energy_type" title="エネルギーの種類">
                <option value="">-</option>
                <option>Grass</option><option>Fire</option><option>Water</option>
                <option>Lightning</option><option>Psychic</option><option>Fighting</option>
                <option>Darkness</option><option>Metal</option><option>Fairy</option>
                <option>Dragon</option><option>Colorless</option>
              </select>
            </div>
            <div class="field">
              <label>エフェクト (effect_ja / effect_en)</label>
              <textarea id="energy_effect" placeholder="日本語エフェクト / English effect"></textarea>
            </div>
            <div class="field">
              <label>ルール (rules_ja / rules_en)</label>
              <textarea id="energy_rules" placeholder="日本語ルール / English rules"></textarea>
            </div>
          </div>

          <div id="trainerFields" class="section">
            <h3>トレーナー</h3>
            <div class="grid-2">
              <div class="field"><label for="trainer_type">トレーナータイプ</label>
                <select id="trainer_type" title="トレーナーカードの種類">
                  <option value="">-</option>
                  <option>Item</option>
                  <option>Supporter</option>
                  <option>Stadium</option>
                </select>
              </div>
            </div>
            <div class="field"><label>テキスト (text_ja / text_en)</label><textarea id="trainer_text" placeholder="日本語 / English"></textarea></div>
          </div>

          <div class="section">
            <h3>画像</h3>
            <div class="field">
              <label for="image_file">画像ファイル名</label>
              <input id="image_file" placeholder="自動生成されます" title="画像ファイル名" readonly style="background: rgba(0,0,0,0.1);"/>
            </div>
            
            <!-- 隠しファイル入力 -->
            <input type="file" id="image_upload" accept="image/*" style="display: none;" title="画像ファイルを選択"/>
            
            <div class="flex-row" style="align-items:center; gap:8px; margin-top:12px; flex-wrap: wrap;">
              <button type="button" class="btn primary" id="btn-pick-image">🖼️ 画像を選択</button>
              <button type="button" class="btn" id="btn-gallery">📁 既存画像</button>
            </div>
            
            <!-- 画像が設定されている場合のみ表示される操作ボタン -->
            <div id="image-actions" style="margin-top:8px; display:none;">
              <div class="flex-row" style="gap:8px; flex-wrap: wrap;">
                <button type="button" class="btn" id="btn-optimize-image">⚡ WebP最適化</button>
                <button type="button" class="btn btn-danger" id="btn-delete-image">🗑️ 削除</button>
              </div>
            </div>
            
            <div id="image-upload-status" style="font-size: 12px; color: var(--text-secondary); margin-top: 8px; display: none;">
              <!-- 画像状況を表示 -->
            </div>
          </div>
        </form>
      </div>
      <div class="footer">
        <div class="toolbar">
          <button type="button" class="btn" id="btn-duplicate">複製</button>
          <button type="button" class="btn danger" id="btn-delete">削除</button>
        </div>
        <div class="spacer"></div>
        <div class="status" id="status">準備中...</div>
      </div>
    </section>
  </div>

  <!-- Slide-out drawer: カード一覧 -->
  <aside id="drawer" aria-hidden="true">
    <div class="drawer-panel">
      <div class="list-toolbar">
        <div class="search"><input id="search" placeholder="検索: 英名/和名/ID (Escで閉じる)" /></div>
        <select id="filterType" class="btn">
          <option value="all">全て</option>
          <option value="Pokemon">ポケモン</option>
          <option value="Energy">エネルギー</option>
          <option value="Trainer">トレーナー</option>
        </select>
        <button type="button" class="btn" id="btn-new">新規</button>
        <button type="button" class="btn ghost" id="btn-close-drawer">✕</button>
      </div>
      <div class="count" id="count"></div>
      <div class="list" id="cardList"></div>
    </div>
    <div class="drawer-backdrop" id="drawer-backdrop"></div>
  </aside>

  <!-- Modal -->
  <div id="modal" class="invisible">
    <div id="modal-backdrop" style="position:fixed; inset:0; background:rgba(0,0,0,.45);"></div>
    <div id="modal-panel" style="position:fixed; top:10%; left:50%; transform:translateX(-50%); width: min(720px, 92vw); max-height: 80vh; overflow:auto; background: linear-gradient(180deg, rgba(21,25,58,.98), rgba(28,34,82,.98)); border:1px solid var(--border); border-radius: 14px; box-shadow: var(--shadow); padding: 16px;"></div>
  </div>

  <script>
    // --------- 型・初期データ
    const defaultCard = () => ({ id: '', name_en: '', name_ja: '', card_type: 'Pokemon' });
    let cards = [];
    let filtered = [];
    let activeIndex = -1;

    let unsaved = false;                   // 未保存フラグ

    // Preview state
    let zoomLevel = 1;
    let pan = { x: 0, y: 0 };
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    let lastPan = { x: 0, y: 0 };

    // --------- ユーティリティ
    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));
    const byId = (id) => document.getElementById(id);
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    // --------- ID自動生成
    /**
     * ID生成システム（data-manager.jsと統一）
     * 3桁ゼロパディング形式でユニークなIDを生成
     */
    function generateNextId() {
      const usedIds = new Set();
      let nextAutoId = 1;
      
      // 既存IDを収集・正規化
      cards.forEach(c => {
        if (c.id) {
          // IDを3桁ゼロパディング形式に正規化
          const numericId = parseInt(c.id, 10);
          if (!isNaN(numericId) && numericId > 0) {
            const normalizedId = String(numericId).padStart(3, '0');
            usedIds.add(normalizedId);
            nextAutoId = Math.max(nextAutoId, numericId + 1);
          } else {
            // 数値以外のIDもそのまま記録
            usedIds.add(String(c.id));
          }
        }
      });
      
      // ユニークなIDを生成
      let candidateId = nextAutoId;
      let formattedId;
      
      do {
        formattedId = String(candidateId).padStart(3, '0');
        candidateId++;
      } while (usedIds.has(formattedId));
      
      console.log(`🆔 Generated new ID: ${formattedId} (next available after checking ${usedIds.size} existing IDs)`);
      return formattedId;
    }

    const schemaGuard = (obj) => {
      // 入力フォーム → スキーマ整形
      const card_type = byId('card_type').value;
      const base = {
        id: byId('id').value.trim(),
        name_en: byId('name_en').value.trim(),
        name_ja: byId('name_ja').value.trim(),
        card_type
      };
      if (card_type === 'Pokemon') {
        const abilityText = byId('ability_text').value.trim();
        const [ability_ja, ability_en_text] = abilityText.split('/').map(s => (s||'').trim());
        const weakStr = byId('weakness').value.trim();
        const weakness = weakStr ? weakStr.split(';').map(s => s.trim()).filter(Boolean).map(tok => {
          const [type, value] = tok.split(':').map(t=>t.trim());
          return { type, value };
        }) : undefined;
        const resStr = byId('resistance').value.trim();
        const resistance = resStr ? (()=>{ const [type,value] = resStr.split(':').map(s=>s.trim()); return { type, value }; })() : undefined;

        obj = {
          ...base,
          stage: byId('stage').value || undefined,
          evolves_from: byId('evolves_from').value.trim() || undefined,
          evolves_to: (byId('evolves_to').value.trim() ? byId('evolves_to').value.split(',').map(s=>s.trim()).filter(Boolean) : undefined),
          hp: byId('hp').value ? Number(byId('hp').value) : undefined,
          types: (byId('types').value.trim() ? byId('types').value.split(',').map(s=>s.trim()).filter(Boolean) : undefined),
          rule_box: (byId('rule_box').value || undefined),
          weakness,
          resistance,
          retreat_cost: byId('retreat_cost').value ? Number(byId('retreat_cost').value) : 0,
          ability: (byId('ability_name').value.trim() || abilityText) ? {
            name_en: byId('ability_name').value.trim() || '',
            name_ja: byId('ability_name').value.trim() || '',
            text_en: ability_en_text || '',
            text_ja: ability_ja || ''
          } : undefined,
          attacks: readAttacksFromForm(),
        };
      } else if (card_type === 'Energy') {
        const effectTxt = byId('energy_effect').value.trim();
        const [effectJa, effectEn] = effectTxt.split('/').map(s => (s||'').trim());
        const rulesTxt = byId('energy_rules').value.trim();
        const [rulesJa, rulesEn] = rulesTxt.split('/').map(s => (s||'').trim());
        obj = {
          ...base,
          energy_type: byId('energy_type').value || undefined,
          effect_en: effectEn || undefined,
          effect_ja: effectJa || undefined,
          rules_en: rulesEn || undefined,
          rules_ja: rulesJa || undefined,
        };
      } else if (card_type === 'Trainer') {
        const txt = byId('trainer_text').value.trim();
        const [ja, en] = txt.split('/').map(s => (s||'').trim());
        obj = {
          ...base,
          trainer_type: byId('trainer_type').value || undefined,
          text_en: en || undefined,
          text_ja: ja || undefined,
        };
      }
      const img = byId('image_file').value.trim();
      if (img) obj.image_file = img; // 任意プロパティ
      return compactObject(obj);
    };

    function compactObject(o){
      if (o === null || o === undefined) return undefined;
      if (Array.isArray(o)) {
        const arr = o.map(compactObject).filter(v => v !== undefined);
        return arr.length ? arr : undefined;
      }
      if (typeof o === 'object') {
        const out = {};
        for (const [k,v] of Object.entries(o)) {
          const vv = compactObject(v);
          if (vv !== undefined && vv !== '') out[k] = vv;
        }
        return Object.keys(out).length ? out : undefined;
      }
      return o;
    }

    function readAttacksFromForm(){
      const containers = $$('#attacks .attack-box');
      return containers.map(node => {
        const name = node.querySelector('.atk-name').value.trim();
        const nameEn = node.querySelector('.atk-name-en').value.trim();
        const cost = node.querySelector('.atk-cost').value.trim();
        const dmg = node.querySelector('.atk-dmg').value;
        const text = node.querySelector('.atk-text').value.trim();
        const [ja, en] = text.split('/').map(s => (s||'').trim());
        const costArray = cost ? cost.split(',').map(s=>s.trim()).filter(Boolean) : [];
        const atk = {
          name_ja: name || undefined,
          name_en: nameEn || undefined,
          cost: costArray,
        };
        if (dmg !== '') atk.damage = Number(dmg);
        if (ja) atk.text_ja = ja;
        if (en) atk.text_en = en;
        return atk;
      });
    }

    function writeAttacksToForm(attacks){
      const root = byId('attacks');
      root.innerHTML = '';
      (attacks || []).forEach((a, idx) => root.appendChild(createAttackBox(a, idx)));
    }

    function createAttackBox(a = {}, idx = 0){
      const box = document.createElement('div');
      box.className = 'attack-box';
      box.innerHTML = `
        <div class="attack-grid">
          <div class="field"><label>技名(和)</label><input class="atk-name" value="${a.name_ja||''}"></div>
          <div class="field"><label>技名(英)</label><input class="atk-name-en" value="${a.name_en||''}"></div>
          <div class="field"><label>コスト(カンマ)</label><input class="atk-cost" placeholder="Grass,Colorless" value="${(a.cost||[]).join(',')}"></div>
        </div>
        <div class="attack-grid">
          <div class="field"><label>ダメージ</label><input class="atk-dmg" type="number" min="0" value="${a.damage ?? ''}"></div>
          <div class="field" style="grid-column: span 2"><label>テキスト(日/英)</label><input class="atk-text" placeholder="日本語 / English" value="${[a.text_ja||'', a.text_en||''].filter((x,i)=>x&&(i<2)).join(' / ')}"></div>
        </div>
        <div class="right"><button type="button" class="btn danger btn-del-atk">削除</button></div>
      `;
      box.querySelector('.btn-del-atk').addEventListener('click', () => {
        box.remove();
      });
      return box;
    }

    function setStatus(msg){ byId('status').textContent = msg; }
    function markUnsaved(flag = true){
      unsaved = flag;
      document.documentElement.style.setProperty('--unsaved-dot', flag ? '"●"' : '""');
      if (flag) setStatus('未保存の変更があります');
    }

    // --------- リスト表示
    function renderList(){
      const q = byId('search').value.trim().toLowerCase();
      const f = byId('filterType').value;
      filtered = cards.filter(c =>
        (f==='all'||c.card_type===f) &&
        ([c.id, c.name_en, c.name_ja].join(' ').toLowerCase().includes(q))
      );
      const list = byId('cardList');
      list.innerHTML = '';
      filtered.forEach((c, i) => {
        const row = document.createElement('div');
        const isActive = cards[activeIndex] === c;
        row.className = 'card-item' + (isActive ? ' active' : '');
        const badgeClass = c.card_type === 'Pokemon' ? 'pokemon' : (c.card_type === 'Energy' ? 'energy' : 'trainer');
        row.innerHTML = `
          <span class="badge ${badgeClass}">${c.card_type}</span>
          <div>
            <div><strong>${c.name_ja||''}</strong> <span class="muted">${c.name_en||''}</span></div>
            <div class="small muted">${c.id||''}</div>
          </div>
          <div class="small muted">${summary(c)}</div>
        `;
        row.addEventListener('click', () => selectByFilteredIndex(i));
        list.appendChild(row);
      });
      byId('count').textContent = `表示 ${filtered.length} / 全体 ${cards.length}`;
    }

    function summary(c){
      if (c.card_type === 'Pokemon') return [c.stage, c.hp?`HP${c.hp}`:'', (c.types||[]).join('/')].filter(Boolean).join(' · ');
      if (c.card_type === 'Energy') return c.energy_type || 'Energy';
      if (c.card_type === 'Trainer') return c.trainer_type || '';
      return '';
    }

    function selectByFilteredIndex(fi){
      const card = filtered[fi];
      const absoluteIndex = cards.findIndex(c => c === card);
      if (absoluteIndex === -1) return;
      activeIndex = absoluteIndex;
      writeForm(cards[activeIndex]);
      updatePreview();
      renderList();
    }

    // --------- フォーム <-> データ
    function writeForm(card){
      const c = card || defaultCard();
      byId('id').value = c.id || '';
      byId('card_type').value = c.card_type || 'Pokemon';
      byId('name_en').value = c.name_en || '';
      byId('name_ja').value = c.name_ja || '';

      // Pokemon
      byId('stage').value = c.stage || '';
      byId('hp').value = c.hp ?? '';
      byId('evolves_from').value = c.evolves_from || '';
      byId('evolves_to').value = (c.evolves_to||[]).join(',');
      byId('types').value = (c.types||[]).join(',');
      byId('rule_box').value = c.rule_box || '';
      byId('weakness').value = (c.weakness||[]).map(w=>`${w.type}:${w.value}`).join('; ');
      byId('resistance').value = c.resistance? `${c.resistance.type}:${c.resistance.value}` : '';
      byId('retreat_cost').value = c.retreat_cost ?? '';
      byId('ability_name').value = c.ability?.name_ja || '';
      byId('ability_text').value = [c.ability?.text_ja||'', c.ability?.text_en||''].filter((x,i)=>x&&(i<2)).join(' / ');
      writeAttacksToForm(c.attacks);

      // Energy
      byId('energy_type').value = c.energy_type || '';
      byId('energy_effect').value = [c.effect_ja||'', c.effect_en||''].filter((x,i)=>x&&(i<2)).join(' / ');
      byId('energy_rules').value = [c.rules_ja||'', c.rules_en||''].filter((x,i)=>x&&(i<2)).join(' / ');

      // Trainer
      byId('trainer_type').value = c.trainer_type || '';
      byId('trainer_text').value = [c.text_ja||'', c.text_en||''].filter((x,i)=>x&&(i<2)).join(' / ');

      // Image
      byId('image_file').value = c.image_file || '';
      updateImageActions();

      onTypeChange();
      setStatus('編集: ' + (c.id || '(新規)'));
      updatePreview();
    }

    function readForm(){
      return schemaGuard({});
    }

    function onTypeChange(){
      const t = byId('card_type').value;
      byId('pokemonFields').style.display = (t==='Pokemon') ? '' : 'none';
      byId('energyFields').style.display  = (t==='Energy') ? '' : 'none';
      byId('trainerFields').style.display = (t==='Trainer') ? '' : 'none';
    }

    // --------- CRUD
    function newCard(){
      const c = defaultCard();
      c.id = generateNextId(); // 自動ID生成
      activeIndex = cards.push(c) - 1;
      writeForm(c);
      renderList();
      updatePreview();
      markUnsaved(true);
      setStatus(`新しいカード (ID: ${c.id}) を作成しました。情報を入力して「master保存」で保存してください。`);
      // 新規作成時は名前入力フィールドにフォーカス
      setTimeout(() => {
        const nameInput = byId('name_en');
        if (nameInput) nameInput.focus();
      }, 100);
    }

    /**
     * 現在編集中のカードをリストに保存
     * data-manager.jsの正規化ロジックと統一
     */
    function saveCurrentIntoList(){
      const rawData = readForm();
      
      // データ正規化を適用
      const data = normalizeCardForEditor(rawData);
      
      // 基本必須項目チェック
      if (!data || !data.id || !data.name_en || !data.name_ja || !data.card_type){
        alert('❌ 必須項目が未入力です:\n• ID\n• 英語名 (name_en)\n• 日本語名 (name_ja)\n• カード種別 (card_type)');
        return false;
      }
      
      // IDは自動生成されるため重複チェック不要（念のため警告のみ）
      const dup = cards.findIndex((c, i) => c.id === data.id && i !== activeIndex);
      if (dup !== -1){
        console.warn(`⚠️ ID重複検出（通常発生しない）: ${data.id}`);
      }
      
      // カード種別別の詳細チェック
      const validationErrors = validateCardData(data);
      if (validationErrors.length > 0) {
        const errorMsg = '❌ 以下の項目に問題があります:\n\n' + validationErrors.join('\n');
        alert(errorMsg);
        return false;
      }
      
      // 画像ファイル名と英語名の整合性チェック（警告のみ）
      const imageWarnings = checkImageConsistency(data);
      if (imageWarnings.length > 0) {
        const proceed = confirm(
          '⚠️ 画像に関する警告があります:\n\n' + 
          imageWarnings.join('\n') + 
          '\n\nそのまま保存しますか？'
        );
        if (!proceed) return false;
      }
      
      if (activeIndex === -1){
        activeIndex = cards.push(data) - 1;
      } else {
        cards[activeIndex] = data;
      }
      setStatus(`✅ カードを保存: ${data.name_en} (ID: ${data.id}) [${data.card_type}]`);
      renderList();
      updatePreview();
      markUnsaved(false);
      return true;
    }

    /**
     * エディター用カードデータ正規化
     * data-manager.jsの正規化ロジックと統一
     */
    function normalizeCardForEditor(card) {
      const normalized = { ...card };
      
      // === ID正規化 ===
      if (!normalized.id || normalized.id.trim() === '') {
        normalized.id = generateNextId();
      } else {
        // 3桁ゼロパディング形式に正規化
        const numericId = parseInt(normalized.id, 10);
        if (!isNaN(numericId) && numericId > 0) {
          normalized.id = String(numericId).padStart(3, '0');
        }
      }
      
      // === カードタイプ正規化 ===
      if (normalized.card_type === 'Pokemon') {
        normalized.card_type = 'Pokémon';
      }
      
      // === 画像フィールド統一 ===
      if (!normalized.image_file && normalized.image) {
        normalized.image_file = normalized.image;
        delete normalized.image;
      }
      
      // 空の画像フィールドをクリア
      if (normalized.image_file === '' || normalized.image_file === null) {
        delete normalized.image_file;
      }
      
      // === ステージ正規化 ===
      if (normalized.stage === 'Basic') normalized.stage = 'BASIC';
      if (normalized.stage === 'Stage1') normalized.stage = 'STAGE1';
      if (normalized.stage === 'Stage2') normalized.stage = 'STAGE2';
      
      // === 必須フィールド警告 ===
      const warnings = [];
      if (!normalized.name_en) warnings.push('英語名が未設定');
      if (!normalized.name_ja) warnings.push('日本語名が未設定');
      
      if (warnings.length > 0) {
        console.warn(`⚠️ Card warnings for ID ${normalized.id}:`, warnings);
      }
      
      return normalized;
    }
    
    function validateCardData(data) {
      const errors = [];
      
      if (data.card_type === 'Pokemon') {
        // ポケモンカードの必須チェック
        if (!data.stage) {
          errors.push('• ポケモンカード: ステージが未設定');
        }
        if (!data.hp || data.hp <= 0) {
          errors.push('• ポケモンカード: HPが未設定または0以下');
        }
        if (!data.types || data.types.length === 0) {
          errors.push('• ポケモンカード: タイプが未設定');
        }
        if (data.retreat_cost === undefined || data.retreat_cost < 0) {
          errors.push('• ポケモンカード: にげるエネルギーが未設定');
        }
        // 攻撃が1つも設定されていない場合
        if (!data.attacks || data.attacks.length === 0) {
          errors.push('• ポケモンカード: 攻撃が1つも設定されていません');
        } else {
          // 攻撃の内容チェック
          data.attacks.forEach((attack, idx) => {
            if (!attack.name_ja && !attack.name_en) {
              errors.push(`• 攻撃${idx + 1}: 技名が未設定`);
            }
            if (!attack.cost || attack.cost.length === 0) {
              errors.push(`• 攻撃${idx + 1}: エネルギーコストが未設定`);
            }
          });
        }
      } else if (data.card_type === 'Energy') {
        // エネルギーカードの必須チェック
        if (!data.energy_type) {
          errors.push('• エネルギーカード: エネルギータイプが未設定');
        }
      } else if (data.card_type === 'Trainer') {
        // トレーナーカードの必須チェック
        if (!data.trainer_type) {
          errors.push('• トレーナーカード: トレーナータイプが未設定');
        }
        if (!data.text_ja && !data.text_en) {
          errors.push('• トレーナーカード: 効果テキストが未設定');
        }
      }
      
      return errors;
    }
    
    function checkImageConsistency(data) {
      const warnings = [];
      const imageFile = data.image_file || '';
      
      if (!imageFile) {
        warnings.push('• 画像ファイル名が設定されていません');
        return warnings;
      }
      
      // 画像拡張子チェック
      const extMatch = imageFile.toLowerCase().match(/\.[^.]+$/);
      const ext = extMatch ? extMatch[0] : '';
      const allowedExts = ['.webp', '.jpg', '.jpeg', '.png'];
      if (!allowedExts.includes(ext)) {
        warnings.push('• 画像ファイルがサポートされていない形式です (対応: .webp/.jpg/.jpeg/.png)');
      }
      
      // 英語名との整合性チェック（ポケモンカードの場合）
      if (data.card_type === 'Pokemon' && data.name_en) {
        const expectedFileName = data.name_en.replace(/[^A-Za-z0-9]+/g, '_') + ext;
        const fileNameWithoutExt = imageFile.replace(/\.[^.]+$/, '');
        const nameEnNormalized = data.name_en.replace(/[^A-Za-z0-9]+/g, '_');
        
        // ファイル名と英語名が大きく異なる場合
        if (!fileNameWithoutExt.toLowerCase().includes(nameEnNormalized.toLowerCase()) && 
            !nameEnNormalized.toLowerCase().includes(fileNameWithoutExt.toLowerCase())) {
          warnings.push(`• 画像ファイル名「${imageFile}」と英語名「${data.name_en}」が一致しません\n  推奨ファイル名: ${expectedFileName}`);
        }
      }
      
      // エネルギーカードの場合の命名チェック
      if (data.card_type === 'Energy' && data.energy_type) {
        const expectedFileName = `Energy_${data.energy_type}${ext}`;
        if (imageFile !== expectedFileName) {
          warnings.push(`• エネルギーカードの画像ファイル名が標準と異なります\n  推奨ファイル名: ${expectedFileName}`);
        }
      }
      
      return warnings;
    }

    function duplicateCard(){
      if (activeIndex < 0) return;
      const src = JSON.parse(JSON.stringify(cards[activeIndex]));
      const originalName = src.name_ja || src.name_en || src.id;
      src.id = generateNextId(); // 自動ID生成
      cards.splice(activeIndex+1, 0, src);
      activeIndex = activeIndex+1;
      writeForm(src);
      renderList();
      updatePreview();
      markUnsaved(true);
      setStatus(`「${originalName}」を複製しました (新ID: ${src.id})。必要に応じて編集してください。`);
    }

    function deleteCard(){
      if (activeIndex < 0) return;
      const c = cards[activeIndex];
      if (!confirm(`削除しますか？\n${c.id} ${c.name_ja}`)) return;
      cards.splice(activeIndex, 1);
      activeIndex = -1;
      writeForm(defaultCard());
      renderList();
      updatePreview();
      markUnsaved(true);
    }

    // --------- 読み込み/保存（シンプル化）

    function normalizeToSpec(arr){
      if (!Array.isArray(arr)) return [];
      return arr.map(c => {
        const out = { ...c };
        // card_type normalize
        if (out.card_type === 'Pokémon') out.card_type = 'Pokemon';
        if (typeof out.card_type === 'string' && out.card_type.includes('Energy')) out.card_type = 'Energy';
        // type -> types
        if (!out.types && out.type) { out.types = [String(out.type)]; delete out.type; }
        // weakness object -> array
        if (out.weakness && !Array.isArray(out.weakness)) { out.weakness = [out.weakness]; }
        // retreat_cost array -> number
        if (Array.isArray(out.retreat_cost)) { out.retreat_cost = out.retreat_cost.length; }
        // stage uppercase -> proper
        if (out.stage === 'BASIC') out.stage = 'Basic';
        if (out.stage === 'STAGE1') out.stage = 'Stage1';
        if (out.stage === 'STAGE2') out.stage = 'Stage2';
        // ability effect_* -> text_*
        if (out.ability && (out.ability.effect_en || out.ability.effect_ja)) {
          out.ability = {
            name_en: out.ability.name_en || '',
            name_ja: out.ability.name_ja || '',
            text_en: out.ability.effect_en || out.ability.text_en || '',
            text_ja: out.ability.effect_ja || out.ability.text_ja || ''
          };
        }
        // attacks effect_* -> text_*
        if (Array.isArray(out.attacks)){
          out.attacks = out.attacks.map(a => ({
            name_en: a.name_en || '',
            name_ja: a.name_ja || '',
            cost: Array.isArray(a.cost) ? a.cost : [],
            damage: (a.damage === 0 || a.damage) ? Number(a.damage) : undefined,
            text_en: a.effect_en || a.text_en || undefined,
            text_ja: a.effect_ja || a.text_ja || undefined,
          }));
        }
        // image -> image_file
        if (!out.image_file && out.image) out.image_file = out.image;
        return out;
      });
    }

    async function openMaster(){
      // 1) まず fetch でローカル同梱を試す
      try {
        const res = await fetch('data/cards-master.json', { cache: 'no-cache' });
        if (res.ok){
          cards = normalizeToSpec(await res.json());
          if (cards.length > 0) {
            activeIndex = 0;
            writeForm(cards[0]);
          } else {
            activeIndex = -1;
            writeForm(defaultCard());
          }
          renderList();
          setStatus('ローカル同梱の master を読込');
          updatePreview();
          return;
        }
      } catch {}

      // 2) ファイル選択で読み込み
      try {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const text = await file.text();
          cards = normalizeToSpec(JSON.parse(text));
          if (!Array.isArray(cards)) cards = [];
          if (cards.length > 0) {
            activeIndex = 0;
            writeForm(cards[0]);
          } else {
            activeIndex = -1;
            writeForm(defaultCard());
          }
          renderList();
          setStatus('master を読み込みました');
          updatePreview();
        };
        input.click();
      } catch (e) {
        console.error(e);
        alert('master の読み込みに失敗しました');
      }
    }

    function findDuplicateIds() {
      const idCounts = {};
      const duplicates = [];
      
      cards.forEach(card => {
        if (card.id) {
          idCounts[card.id] = (idCounts[card.id] || 0) + 1;
        }
      });
      
      for (const [id, count] of Object.entries(idCounts)) {
        if (count > 1) {
          duplicates.push(`ID "${id}" が ${count} 回使用されています`);
        }
      }
      
      return duplicates;
    }

    async function processAndSaveImages() {
      // Current card's image processing
      const fileInput = byId('image_upload');
      if (fileInput.files && fileInput.files.length > 0) {
        setStatus('画像を.webpに変換中...');
        try {
          await saveImageAsWebP(fileInput.files[0]);
          // Clear the file input after successful save
          fileInput.value = '';
          const statusDiv = byId('image-upload-status');
          statusDiv.textContent = '✅ 画像が.webpに変換され保存されました';
          statusDiv.style.color = 'var(--ok)';
        } catch (error) {
          console.error('Image save failed:', error);
          // エラーが「置き換えキャンセル」の場合はスキップ
          if (error.message === '画像の置き換えがキャンセルされました') {
            console.log('画像の置き換えがキャンセルされました');
            return; // エラーを投げずにスキップ
          }
          throw new Error(`画像の保存に失敗しました: ${error.message}`);
        }
      }
    }

    async function saveImageAsWebP(file) {
      const cardType = (byId('card_type').value || 'Pokemon').toLowerCase();
      const cardId = byId('id').value.trim();
      const nameEn = byId('name_en').value.trim();
      
      // アップロードされたファイルの種類をチェック
      const isAlreadyWebP = file.type === 'image/webp' || file.name.toLowerCase().endsWith('.webp');
      
      // 既存の画像ファイルがある場合は削除確認
      const currentCard = cards[activeIndex];
      const oldFileName = currentCard?.image_file;
      let shouldDeleteOld = false;
      
      if (oldFileName) {
        // 自動で生成される新しいファイル名を先に計算
        let newFileName;
        if (cardType === 'energy') {
          const energyType = byId('energy_type').value.trim();
          newFileName = energyType ? `${cardId}_Energy_${energyType}.webp` : `${cardId}.webp`;
        } else {
          const safeName = nameEn ? nameEn.replace(/[^A-Za-z0-9\-]+/g, '_') : 'Card';
          newFileName = `${cardId}_${cardType}_${safeName}.webp`;
        }
        
        // 古いファイル名と新しいファイル名が同じ場合は処理をスキップ
        if (oldFileName === newFileName && isAlreadyWebP) {
          console.log(`既存のWebPファイルと同名のため処理をスキップ: ${oldFileName}`);
          return { filename: oldFileName, path: `assets/cards/${cardType}/${oldFileName}` };
        }
        
        // ファイル名が異なるか、WebP以外からの変換の場合は削除確認
        shouldDeleteOld = confirm(
          `既存の画像ファイル「${oldFileName}」を削除して新しい画像に置き換えますか？\n\n` +
          `新しいファイル名: ${newFileName}\n\n` +
          '「はい」: 古い画像を削除して新しい画像を保存\n' +
          '「いいえ」: キャンセル'
        );
        if (!shouldDeleteOld) {
          throw new Error('画像の置き換えがキャンセルされました');
        }
      }
      
      // ファイル名を再計算（上で計算済みの場合はそれを使用）
      let fileName;
      if (cardType === 'energy') {
        const energyType = byId('energy_type').value.trim();
        fileName = energyType ? `${cardId}_Energy_${energyType}.webp` : `${cardId}.webp`;
      } else {
        // IDとプレフィックスを使用して標準的な命名
        const safeName = nameEn ? nameEn.replace(/[^A-Za-z0-9\-]+/g, '_') : 'Card';
        fileName = `${cardId}_${cardType}_${safeName}.webp`;
      }
      
      // UIに新しいファイル名を設定
      byId('image_file').value = fileName;
      
      // 既にWebPの場合は直接保存、そうでなければCanvas変換
      return new Promise((resolve, reject) => {
        const processAndSave = async (blob) => {
          try {
            // Try CardAPI first
            if (window.CardAPI && window.CardAPI.uploadImage) {
              // 古いファイルを先に削除
              if (shouldDeleteOld && oldFileName && oldFileName !== fileName) {
                try {
                  if (window.CardAPI.deleteImage) {
                    await window.CardAPI.deleteImage(oldFileName);
                    console.log(`削除された古い画像ファイル (API): ${oldFileName}`);
                  }
                } catch (deleteError) {
                  console.warn(`古いファイルの削除に失敗 (API): ${oldFileName}`, deleteError);
                }
              }
              
              const result = await window.CardAPI.uploadImage(blob, {
                filename: fileName,
                cardType: cardType,
                cardId: cardId
              });
              
              if (result && result.path) {
                const currentCard = cards[activeIndex];
                if (currentCard) {
                  currentCard.image_file = result.filename || fileName;
                  currentCard.image_url = result.path;
                }
                updatePreview();
                resolve(result);
                return;
              }
            }
            
            // Fallback to file system API
            if ('showDirectoryPicker' in window) {
              const dirHandle = await window.showDirectoryPicker();
              const assetsHandle = await dirHandle.getDirectoryHandle('assets', { create: true });
              const cardsHandle = await assetsHandle.getDirectoryHandle('cards', { create: true });
              const typeHandle = await cardsHandle.getDirectoryHandle(cardType, { create: true });
              
              // 古いファイルを削除
              if (shouldDeleteOld && oldFileName && oldFileName !== fileName) {
                try {
                  await typeHandle.removeEntry(oldFileName);
                  console.log(`削除された古い画像ファイル: ${oldFileName}`);
                } catch (deleteError) {
                  console.warn(`古いファイルの削除に失敗: ${oldFileName}`, deleteError);
                  // 削除に失敗しても処理を続行
                }
              }
              
              const fileHandle = await typeHandle.getFileHandle(fileName, { create: true });
              const writable = await fileHandle.createWritable();
              await writable.write(blob);
              await writable.close();
              
              const currentCard = cards[activeIndex];
              if (currentCard) {
                currentCard.image_file = fileName;
              }
              updatePreview();
              resolve({ filename: fileName, path: `assets/cards/${cardType}/${fileName}` });
            } else {
              reject(new Error('File system API not supported'));
            }
          } catch (error) {
            reject(error);
          }
        };

        // 既にWebPファイルの場合は直接保存
        if (isAlreadyWebP) {
          console.log('既にWebPファイルのため直接保存します');
          processAndSave(file);
        } else {
          // WebP以外の場合はCanvas変換
          console.log('WebPに変換中...');
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          const img = new Image();
          
          img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            canvas.toBlob(processAndSave, 'image/webp', 0.9);
          };
          
          img.onerror = () => reject(new Error('Image load failed'));
          img.src = URL.createObjectURL(file);
        }
      });
    }

    async function saveMaster(){
      if (!saveCurrentIntoList()) return;
      
      // Process any pending image uploads with WebP conversion
      await processAndSaveImages();
      
      // Check for ID-based duplicates before saving
      const duplicateIds = findDuplicateIds();
      if (duplicateIds.length > 0) {
        const proceed = confirm(
          '⚠️ 重複IDが見つかりました:\n\n' + 
          duplicateIds.join('\n') + 
          '\n\nそのまま保存しますか？'
        );
        if (!proceed) return;
      }
      
      const json = JSON.stringify(cards, null, 2);
      try {
        const res = await fetch('data/cards-master.json', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json; charset=utf-8' },
          body: json
        });
        if (!res.ok) throw new Error('save failed');
        setStatus('master を保存しました');
        markUnsaved(false);
      } catch (e) {
        console.error(e);
        alert('master の保存に失敗しました');
      }
    }



    // --------- 初期化
    function bind(){
      byId('filterType').addEventListener('change', renderList);
      byId('search').addEventListener('input', renderList);
      byId('btn-new').addEventListener('click', newCard);
      byId('btn-new-card').addEventListener('click', newCard);
      byId('btn-duplicate').addEventListener('click', duplicateCard);
      byId('btn-delete').addEventListener('click', deleteCard);
      byId('btn-save-master').addEventListener('click', saveMaster);
      byId('btn-open-master').addEventListener('click', openMaster);
      byId('btn-fix-extensions').addEventListener('click', fixAllExtensions);
      byId('btn-back-to-game').addEventListener('click', () => {
        if (unsaved && !confirm('未保存の変更があります。ゲームに戻りますか？')) return;
        window.location.href = 'index.html';
      });
      byId('card_type').addEventListener('change', () => { onTypeChange(); updatePreview(); markUnsaved(true); });
      byId('btn-add-attack').addEventListener('click', () => {
        byId('attacks').appendChild(createAttackBox());
      });

      // Drawer controls
      byId('btn-open-drawer').addEventListener('click', openDrawer);
      byId('btn-close-drawer').addEventListener('click', closeDrawer);
      byId('drawer-backdrop').addEventListener('click', closeDrawer);

      // Preview controls
      byId('btn-prev').addEventListener('click', goPrev);
      byId('btn-next').addEventListener('click', goNext);
      byId('image_upload').addEventListener('change', () => { 
        // 画像選択時に一時的にプレビュー表示（保存は行わない）
        const input = byId('image_upload');
        if (input.files && input.files[0]) {
          const currentFileName = byId('image_file').value.trim();
          if (!currentFileName) {
            const guessedName = guessImageFile();
            if (guessedName) {
              byId('image_file').value = guessedName;
            }
          }
          
          // 一時的なプレビュー表示の状態を示す
          const statusDiv = byId('image-upload-status');
          statusDiv.textContent = '📷 一時プレビュー - カードを保存で.webpに変換されます';
          statusDiv.style.display = 'block';
          statusDiv.style.color = 'var(--warn)';
          updateImageActions();
        }
        updatePreview(); 
        markUnsaved(true); 
      });
      byId('btn-pick-image').addEventListener('click', openImagePicker);
      byId('btn-gallery').addEventListener('click', openImageGallery);
      byId('btn-optimize-image').addEventListener('click', optimizeCurrentImage);
      byId('btn-delete-image').addEventListener('click', deleteCurrentImage);
      byId('zoom').addEventListener('input', (e) => { zoomLevel = Number(e.target.value); applyTransform(); });
      byId('btn-zoom-in').addEventListener('click', () => { zoomLevel = Math.min(3, (zoomLevel + 0.1)); byId('zoom').value = zoomLevel.toFixed(1); applyTransform(); });
      byId('btn-zoom-out').addEventListener('click', () => { zoomLevel = Math.max(0.5, (zoomLevel - 0.1)); byId('zoom').value = zoomLevel.toFixed(1); applyTransform(); });
      byId('btn-fit').addEventListener('click', () => { zoomLevel = 1; pan = {x:0,y:0}; byId('zoom').value = '1'; applyTransform(); });
      byId('btn-actual').addEventListener('click', () => { zoomLevel = 1.5; pan = {x:0,y:0}; byId('zoom').value = String(zoomLevel); applyTransform(); });

      const stage = byId('preview-stage');
      stage.addEventListener('wheel', (e) => {
        if (!e.ctrlKey) return;
        e.preventDefault();
        const delta = Math.sign(e.deltaY) * -0.1;
        zoomLevel = Math.min(3, Math.max(0.5, zoomLevel + delta));
        byId('zoom').value = zoomLevel.toFixed(1);
        applyTransform();
      }, { passive: false });
      stage.addEventListener('mousedown', (e) => { isPanning = true; panStart = { x: e.clientX, y: e.clientY }; lastPan = { ...pan }; });
      window.addEventListener('mousemove', (e) => { if (!isPanning) return; const dx = e.clientX - panStart.x; const dy = e.clientY - panStart.y; pan = { x: lastPan.x + dx, y: lastPan.y + dy }; applyTransform(); });
      window.addEventListener('mouseup', () => { isPanning = false; });

      // Form change detection
      $$('#cardForm input, #cardForm select, #cardForm textarea').forEach(el => {
        el.addEventListener('input', () => { markUnsaved(true); if (el.id.startsWith('image')) updatePreview(); });
        el.addEventListener('change', () => { markUnsaved(true); if (el.id.startsWith('image')) updatePreview(); });
      });

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        if (e.key === 'k' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); openDrawer(); byId('search').focus(); }
        if (e.key === 's' && (e.ctrlKey || e.metaKey) && e.shiftKey) { e.preventDefault(); saveCurrentCardAsFile(); }
        else if (e.key === 's' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); saveMaster(); }
        if (e.key === 'n' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); newCard(); }
        if (e.key === 'ArrowDown') { e.preventDefault(); goNext(); }
        if (e.key === 'ArrowUp') { e.preventDefault(); goPrev(); }
        if (e.key === 'Escape' && isDrawerOpen()) { closeDrawer(); }
      });

      // Warn on unload if unsaved
      window.addEventListener('beforeunload', (e) => { if (unsaved){ e.preventDefault(); e.returnValue = ''; } });
    }


    async function boot(){
      bind();
      adjustLayout();
      window.addEventListener('resize', adjustLayout);
      // 既存の data/cards-master.json を fetch し、可能なら最初に表示
      try {
        const res = await fetch('data/cards-master.json', { cache: 'no-cache' });
        if (res.ok) {
          const raw = await res.json();
          cards = normalizeToSpec(raw);
          activeIndex = cards.length ? 0 : -1;
          renderList();
          writeForm(cards[activeIndex] || defaultCard());
          setStatus('ローカル同梱の master を読み込みました');
          updatePreview();
          return;
        }
      } catch {}
      cards = [];
      renderList();
      writeForm(defaultCard());
      setStatus('新規作成を開始できます。master読込ボタンでJSONファイルを選択できます。');
      updatePreview();
    }

    document.addEventListener('DOMContentLoaded', boot);

    // ---------- Drawer helpers
    function openDrawer(){ byId('drawer').classList.add('open'); }
    function closeDrawer(){ byId('drawer').classList.remove('open'); }
    function isDrawerOpen(){ return byId('drawer').classList.contains('open'); }

    // ---------- Layout helper
    function adjustLayout(){
      const header = document.querySelector('header');
      const container = document.querySelector('.container');
      if (!header || !container) return;
      
      // ヘッダーの実際の高さを取得して、コンテナ高を調整
      const h = header.getBoundingClientRect().height;
      container.style.height = `${window.innerHeight - h}px`;
      
      // 画面サイズに応じた微調整（メディアクエリと合わせる）
      if (window.innerWidth <= 599) {
        container.style.height = `${window.innerHeight - h}px`;
      } else if (window.innerWidth <= 767) {
        container.style.height = `${window.innerHeight - h}px`;
      }
    }

    // ---------- Preview helpers
    function getImageExtension() {
      const name = (byId('image_file').value || '').trim().toLowerCase();
      const match = name.match(/\.[^.]+$/);
      return match ? match[0] : '.webp';
    }
    function currentPreviewUrl(){
      // 1) Uploaded
      const input = byId('image_upload');
      if (input.files && input.files[0]) return URL.createObjectURL(input.files[0]);
      const t = (byId('card_type').value || 'Pokemon').toLowerCase();
      
      // 2) Explicit filename with extension fallback
      const fileName = (byId('image_file').value || '').trim();
      if (fileName) {
        return getImageUrlWithFallback(`assets/cards/${t}/${fileName}`);
      }
      
      const ext = getImageExtension();
      // 3) Auto-map for Energy
      if (t === 'energy'){
        const et = (byId('energy_type').value || '').trim();
        if (et) return getImageUrlWithFallback(`assets/cards/energy/Energy_${et}${ext}`);
      }
      // 4) Heuristic for Pokemon from English name
      if (t === 'pokemon'){
        const en = (byId('name_en').value || '').trim();
        if (en){
          const guess = en.replace(/[^A-Za-z0-9]+/g, '_') + ext;
          return getImageUrlWithFallback(`assets/cards/pokemon/${guess}`);
        }
      }
      // 5) No image
      return '';
    }

    function getImageUrlWithFallback(basePath) {
      // 拡張子候補リスト（優先順位順）
      const extensions = ['.webp', '.jpg', '.jpeg', '.png'];
      const pathWithoutExt = basePath.replace(/\.[^.]+$/, '');
      const currentExt = basePath.match(/\.[^.]+$/)?.[0] || '';
      
      // 元の拡張子が含まれていない場合は追加
      if (currentExt && !extensions.includes(currentExt.toLowerCase())) {
        extensions.unshift(currentExt);
      }
      
      // 元のパスが拡張子を持つ場合、それを最優先にする
      if (currentExt) {
        const filteredExts = extensions.filter(ext => ext !== currentExt);
        return basePath; // まず元のパスを試行（404時にフォールバックはimg.onerrorで処理）
      }
      
      // 拡張子がない場合は.webpを優先
      return pathWithoutExt + '.webp';
    }

    // 404エラーをキャッシュして同じエラーを繰り返さない
    const failedUrls = new Set();
    
    function tryExtensionFallback(imgElement, originalUrl, onAllFailed) {
      // 既にフォールバック処理中の場合は重複実行を防ぐ
      if (imgElement.dataset.fallbackInProgress === 'true') {
        return;
      }
      
      // 既に失敗したURLの場合は即座に失敗として処理
      if (failedUrls.has(originalUrl)) {
        onAllFailed();
        return;
      }
      
      imgElement.dataset.fallbackInProgress = 'true';
      
      const extensions = ['.webp', '.jpg', '.jpeg', '.png'];
      const pathWithoutExt = originalUrl.replace(/\.[^.]+$/, '');
      const currentExt = originalUrl.match(/\.[^.]+$/)?.[0] || '';
      
      // 現在の拡張子以外の候補を取得
      const fallbackExtensions = extensions.filter(ext => ext !== currentExt.toLowerCase());
      
      let attemptIndex = 0;
      
      function tryNextExtension() {
        if (attemptIndex >= fallbackExtensions.length) {
          // 全ての拡張子で失敗した場合
          imgElement.dataset.fallbackInProgress = 'false';
          failedUrls.add(originalUrl); // 失敗したURLをキャッシュ
          onAllFailed();
          return;
        }
        
        const nextUrl = pathWithoutExt + fallbackExtensions[attemptIndex];
        attemptIndex++;
        
        // 既に失敗したURLはスキップ
        if (failedUrls.has(nextUrl)) {
          tryNextExtension();
          return;
        }
        
        // 新しい画像要素を作成してテスト
        const testImg = new Image();
        
        testImg.onload = () => {
          // 成功した場合、メインの画像要素を更新
          imgElement.src = nextUrl;
          imgElement.dataset.fallbackInProgress = 'false';
          
          // 対応する拡張子でファイル名を更新
          const newExtension = fallbackExtensions[attemptIndex - 1];
          const currentFileName = byId('image_file').value.trim();
          if (currentFileName && currentFileName.includes('.')) {
            const newFileName = currentFileName.replace(/\.[^.]+$/, '') + newExtension;
            if (newFileName !== currentFileName) {
              byId('image_file').value = newFileName;
              markUnsaved(true);
              console.log(`画像拡張子を自動修正: ${currentFileName} → ${newFileName}`);
            }
          }
        };
        
        testImg.onerror = () => {
          // この拡張子で失敗した場合、失敗URLをキャッシュして次を試行
          failedUrls.add(nextUrl);
          tryNextExtension();
        };
        
        testImg.src = nextUrl;
      }
      
      // フォールバック開始
      tryNextExtension();
    }
    function updatePreview(){
      const url = currentPreviewUrl();
      const img = byId('preview-img');
      const empty = byId('preview-empty');
      const deleteBtn = byId('btn-delete-image');
      
      if (!url){ 
        img.removeAttribute('src'); 
        empty.style.display = 'block'; 
        deleteBtn.style.display = 'none';
        return; 
      }
      
      img.src = url;
      img.onerror = () => {
        // 既にエラー処理中の場合は重複実行を防ぐ
        if (img.dataset.errorHandled === 'true') return;
        img.dataset.errorHandled = 'true';
        
        // 拡張子フォールバック試行
        tryExtensionFallback(img, url, () => {
          // 全てのフォールバックが失敗した場合
          img.onerror = null;
          img.src = 'assets/ui/card_back.webp';
          empty.textContent = '画像が見つかりません。画像ファイル名またはエネルギータイプを設定してください。';
          empty.style.display = 'block';
          deleteBtn.style.display = 'none';
          console.warn(`Image not found for all extensions: ${url}`);
        });
      };
      img.onload = () => { 
        empty.style.display = 'none'; 
        updateImageActions();
        // エラーハンドリングフラグをクリア
        img.dataset.errorHandled = 'false';
      };
      applyTransform();
      // Reflect current filename into the input (if using assets path)
      try {
        const used = (new URL(url, location.href)).pathname;
        if (used.includes('/assets/cards/')){
          const name = used.split('/').pop();
          if (name && name !== 'card_back.webp'){
            const input = byId('image_file');
            if (input && input.value.trim() !== name) input.value = name;
          }
        }
      } catch {}
    }
    function applyTransform(){
      const img = byId('preview-img');
      img.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${zoomLevel})`;
    }
    // ---------- Image helpers
    function guessImageFile(){
      const cardType = (byId('card_type').value || 'Pokemon').toLowerCase();
      const cardId = (byId('id').value || '').trim();
      const nameEn = (byId('name_en').value || '').trim();
      const ext = getImageExtension();

      if (!cardId) return ''; // IDが必須

      if (cardType === 'energy'){
        const energyType = (byId('energy_type').value || '').trim();
        return energyType ? `${cardId}_Energy_${energyType}${ext}` : `${cardId}${ext}`;
      }

      if (cardType === 'pokemon' || cardType === 'trainer'){
        if (!nameEn) return `${cardId}${ext}`; // 名前がない場合はIDのみ

        // 特別な名前のマッピングをチェック
        const specialNames = {
          "Glasswing Butterfly Larva": "Glasswing_Butterfly_Larva",
          "Cat exv": "Cat_exv",
          "Grey Dagger Moth Larva": "Grey_Dagger_Moth_Larva",
          // Update mapping to reflect hyphenated asset filename
          "Short-horned Grasshopper": "Short-horned_Grasshopper",
          "Tateha Butterfly": "Tateha_Butterfly",
          "Caterpillar exz": "Caterpillar_exz",
          "Taiwan Clouded Yellow": "Taiwan_Clouded_Yellow",
          "Kurohime Crane Fly": "Kurohime_Crane_Fly",
          "Bee ex": "Bee_ex",
          "Hosohari Stinkbug ex": "Hosohari_Stinkbug_ex",
          "Tonosama Grasshopper": "Tonosama_Grasshopper",
          "Rainbow Skink": "Rainbow_Skink",
          "Longhorn Beetle": "Longhorn_Beetle",
          "Tsumamurasaki Madara": "Tsumamurasaki_Madara",
          "Kobane Inago": "Kobane_Inago",
          "Orange Spider": "Orange_Spider"
        };
        
        const fileName = specialNames[nameEn] || nameEn.replace(/[^A-Za-z0-9]+/g, '_');
        return `${cardId}_${fileName}${ext}`;
      }

      return `${cardId}${ext}`;
    }
    function updateImageActions() {
      const filename = byId('image_file').value.trim();
      const imageActionsDiv = byId('image-actions');
      const statusDiv = byId('image-upload-status');
      const optimizeBtn = byId('btn-optimize-image');
      
      if (filename) {
        // 画像が設定されている場合
        imageActionsDiv.style.display = 'block';
        
        // 最適化ボタンの表示制御
        const isOptimizable = !filename.toLowerCase().endsWith('.webp');
        optimizeBtn.style.display = isOptimizable ? 'inline-block' : 'none';
        
        // 状況表示
        if (statusDiv.style.display === 'none') {
          statusDiv.textContent = `📁 ${filename}`;
          statusDiv.style.color = 'var(--text-secondary)';
          statusDiv.style.display = 'block';
        }
      } else {
        // 画像が設定されていない場合
        imageActionsDiv.style.display = 'none';
        statusDiv.style.display = 'none';
      }
    }

    function openImagePicker(){
      // シンプルなファイル選択
      const input = byId('image_upload');
      input.click();
    }
    // ---------- Modal
    function openModal(html){ const panel = byId('modal-panel'); const modal = byId('modal'); if (!panel||!modal) return; panel.innerHTML = html; modal.classList.remove('invisible'); const mb = byId('modal-backdrop'); if (mb) mb.onclick = closeModal; }
    function closeModal(){ const modal = byId('modal'); if (modal) modal.classList.add('invisible'); }

    // ---------- Image Gallery
    async function openImageGallery() {
      try {
        const response = await CardAPI.getAllImages();
        const images = response.images || [];
        
        const html = `
          <div style="max-height: 70vh; overflow-y: auto;">
            <h2 style="margin: 0 0 16px 0; color: var(--text); font-size: 20px;">画像ギャラリー (${images.length}件)</h2>
            
            <!-- Search and Filter Controls -->
            <div style="margin-bottom: 16px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
              <input type="text" id="gallery-search" placeholder="ファイル名で検索..." style="
                flex: 1; min-width: 200px; padding: 6px 10px; border: 1px solid var(--border); 
                border-radius: 6px; background: var(--bg-secondary); color: var(--text);
              " />
              <select id="gallery-filter-type" style="
                padding: 6px 10px; border: 1px solid var(--border); 
                border-radius: 6px; background: var(--bg-secondary); color: var(--text);
              ">
                <option value="">全タイプ</option>
                <option value="energy">Energy</option>
                <option value="pokemon">Pokemon</option>
                <option value="trainer">Trainer</option>
                <option value="legacy">Legacy</option>
              </select>
              <select id="gallery-filter-ext" style="
                padding: 6px 10px; border: 1px solid var(--border); 
                border-radius: 6px; background: var(--bg-secondary); color: var(--text);
              ">
                <option value="">全拡張子</option>
                <option value=".webp">.webp</option>
                <option value=".jpg">.jpg</option>
                <option value=".jpeg">.jpeg</option>
                <option value=".png">.png</option>
              </select>
              <select id="gallery-sort" style="
                padding: 6px 10px; border: 1px solid var(--border); 
                border-radius: 6px; background: var(--bg-secondary); color: var(--text);
              ">
                <option value="name">名前順</option>
                <option value="size">サイズ順</option>
                <option value="date">更新日順</option>
              </select>
            </div>
            
            <div id="gallery-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 12px;">
              ${images.map(img => `
                <div class="gallery-item" data-filename="${img.filename}" style="
                  border: 2px solid var(--border); 
                  border-radius: 8px; 
                  overflow: hidden; 
                  cursor: pointer; 
                  transition: all 0.2s;
                  background: var(--bg-secondary);
                ">
                  <img src="${img.path}" alt="${img.filename}" style="
                    width: 100%; 
                    height: 120px; 
                    object-fit: cover; 
                    display: block;
                  " />
                  <div style="padding: 6px; text-align: center;">
                    <div style="font-size: 11px; color: var(--text-secondary); word-break: break-all;">
                      ${img.filename}
                    </div>
                    <div style="font-size: 10px; color: var(--text-tertiary); margin-top: 2px;">
                      ${(img.size / 1024).toFixed(1)}KB
                    </div>
                  </div>
                </div>
              `).join('')}
            </div>
            <div style="margin-top: 16px; text-align: right;">
              <button onclick="closeModal()" class="btn">閉じる</button>
              <button onclick="showUnusedImages()" class="btn" style="margin-left: 8px;">未使用画像</button>
            </div>
          </div>
        `;
        
        openModal(html);
        
        // 検索・フィルタリング機能
        let filteredImages = [...images];
        
        function updateGalleryDisplay() {
          const searchTerm = byId('gallery-search').value.toLowerCase();
          const extFilter = byId('gallery-filter-ext').value;
          const sortBy = byId('gallery-sort').value;
          
          // フィルタリング
          filteredImages = images.filter(img => {
            const matchesSearch = img.filename.toLowerCase().includes(searchTerm);
            const matchesExt = !extFilter || img.filename.toLowerCase().endsWith(extFilter);
            return matchesSearch && matchesExt;
          });
          
          // ソート
          filteredImages.sort((a, b) => {
            switch(sortBy) {
              case 'name':
                return a.filename.localeCompare(b.filename);
              case 'size':
                return b.size - a.size; // 大きい順
              case 'date':
                return new Date(b.modified) - new Date(a.modified); // 新しい順
              default:
                return 0;
            }
          });
          
          // 表示更新
          const grid = byId('gallery-grid');
          grid.innerHTML = filteredImages.map(img => `
            <div class="gallery-item" data-filename="${img.filename}" style="
              border: 2px solid var(--border); 
              border-radius: 8px; 
              overflow: hidden; 
              cursor: pointer; 
              transition: all 0.2s;
              background: var(--bg-secondary);
            ">
              <img src="${img.path}" alt="${img.filename}" style="
                width: 100%; 
                height: 120px; 
                object-fit: cover; 
                display: block;
              " />
              <div style="padding: 6px; text-align: center;">
                <div style="font-size: 11px; color: var(--text-secondary); word-break: break-all;">
                  ${img.filename}
                </div>
                <div style="font-size: 10px; color: var(--text-tertiary); margin-top: 2px;">
                  ${(img.size / 1024).toFixed(1)}KB
                </div>
              </div>
            </div>
          `).join('');
          
          // イベントリスナー再追加
          attachGalleryEvents();
          
          // 件数表示更新
          const title = document.querySelector('h2');
          title.textContent = `画像ギャラリー (${filteredImages.length}/${images.length}件)`;
        }
        
        function attachGalleryEvents() {
          document.querySelectorAll('.gallery-item').forEach(item => {
            item.addEventListener('click', () => {
              const filename = item.dataset.filename;
              byId('image_file').value = filename;
              updateImageActions();
              updatePreview();
              markUnsaved(true);
              closeModal();
            });
            
            // ホバー効果
            item.addEventListener('mouseenter', () => {
              item.style.borderColor = 'var(--primary)';
              item.style.transform = 'scale(1.05)';
            });
            item.addEventListener('mouseleave', () => {
              item.style.borderColor = 'var(--border)';
              item.style.transform = 'scale(1)';
            });
          });
        }
        
        // 初期表示のイベント設定
        attachGalleryEvents();
        
        // 検索・フィルタイベント
        byId('gallery-search').addEventListener('input', updateGalleryDisplay);
        byId('gallery-filter-ext').addEventListener('change', updateGalleryDisplay);
        byId('gallery-sort').addEventListener('change', updateGalleryDisplay);
        
      } catch (error) {
        console.error('Failed to load image gallery:', error);
        alert('画像ギャラリーの読み込みに失敗しました');
      }
    }

    async function showUnusedImages() {
      try {
        const response = await CardAPI.getUnusedImages();
        const unused = response.unused || [];
        
        if (unused.length === 0) {
          alert('未使用の画像はありません');
          return;
        }
        
        const html = `
          <div style="max-height: 70vh; overflow-y: auto;">
            <h2 style="margin: 0 0 16px 0; color: var(--text); font-size: 20px;">未使用画像 (${unused.length}件)</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 12px;">
              ${unused.map(filename => `
                <div class="unused-item" data-filename="${filename}" style="
                  border: 2px solid #ff6b6b; 
                  border-radius: 8px; 
                  overflow: hidden; 
                  background: var(--bg-secondary);
                  position: relative;
                ">
                  <img src="/assets/cards/${filename}" alt="${filename}" style="
                    width: 100%; 
                    height: 120px; 
                    object-fit: cover; 
                    display: block;
                    opacity: 0.7;
                  " />
                  <div style="padding: 6px; text-align: center;">
                    <div style="font-size: 11px; color: var(--text-secondary); word-break: break-all;">
                      ${filename}
                    </div>
                    <button onclick="deleteUnusedImage('${filename}')" class="btn btn-danger" style="font-size: 10px; padding: 2px 6px; margin-top: 4px;">削除</button>
                  </div>
                </div>
              `).join('')}
            </div>
            <div style="margin-top: 16px; text-align: right;">
              <button onclick="closeModal()" class="btn">閉じる</button>
            </div>
          </div>
        `;
        
        openModal(html);
        
      } catch (error) {
        console.error('Failed to load unused images:', error);
        alert('未使用画像の取得に失敗しました');
      }
    }

    async function deleteUnusedImage(filename) {
      if (!confirm(`画像「${filename}」を削除しますか？この操作は取り消せません。`)) return;
      
      try {
        await CardAPI.deleteImage(filename);
        showUnusedImages(); // リフレッシュ
      } catch (error) {
        console.error('Failed to delete image:', error);
        alert('画像の削除に失敗しました');
      }
    }

    async function deleteCurrentImage() {
      const filename = byId('image_file').value.trim();
      if (!filename) {
        alert('削除する画像ファイル名が指定されていません');
        return;
      }
      
      if (!confirm(`画像「${filename}」を削除しますか？この操作は取り消せません。`)) return;
      
      try {
        await CardAPI.deleteImage(filename);
        byId('image_file').value = '';
        updateImageActions();
        updatePreview();
        markUnsaved(true);
        alert('画像を削除しました');
      } catch (error) {
        console.error('Failed to delete image:', error);
        alert('画像の削除に失敗しました');
      }
    }

    // ---------- Extension Consistency Fixes
    async function fixAllExtensions() {
      if (!confirm('すべてのカードの画像拡張子を実際のファイルと照合して修正しますか？')) return;
      
      try {
        const response = await CardAPI.getAllImages();
        const availableImages = response.images || [];
        const imageMap = new Map();
        
        // 利用可能な画像をマップに登録（拡張子なしのベース名でインデックス）
        availableImages.forEach(img => {
          const baseName = img.filename.replace(/\.[^.]+$/, '').toLowerCase();
          if (!imageMap.has(baseName)) {
            imageMap.set(baseName, []);
          }
          imageMap.get(baseName).push(img.filename);
        });
        
        let fixedCount = 0;
        cards.forEach(card => {
          if (card.image_file) {
            const baseName = card.image_file.replace(/\.[^.]+$/, '').toLowerCase();
            const availableFiles = imageMap.get(baseName);
            
            if (availableFiles && availableFiles.length > 0) {
              // 優先順位: .webp > .jpg > .jpeg > .png
              const preferredOrder = ['.webp', '.jpg', '.jpeg', '.png'];
              let bestMatch = availableFiles[0];
              
              for (const ext of preferredOrder) {
                const candidate = availableFiles.find(f => f.toLowerCase().endsWith(ext));
                if (candidate) {
                  bestMatch = candidate;
                  break;
                }
              }
              
              if (bestMatch !== card.image_file) {
                console.log(`拡張子修正: ${card.image_file} → ${bestMatch} (${card.name_en || card.id})`);
                card.image_file = bestMatch;
                fixedCount++;
              }
            }
          }
        });
        
        if (fixedCount > 0) {
          markUnsaved(true);
          updatePreview();
          renderList();
          alert(`${fixedCount}個のカードの拡張子を修正しました。「master保存」で確定してください。`);
        } else {
          alert('修正が必要な拡張子はありませんでした。');
        }
        
      } catch (error) {
        console.error('Extension fix failed:', error);
        alert('拡張子修正に失敗しました');
      }
    }

    // ---------- Image Optimization
    async function optimizeCurrentImage() {
      const filename = byId('image_file').value.trim();
      if (!filename) {
        alert('最適化する画像ファイル名が指定されていません');
        return;
      }
      
      if (filename.toLowerCase().endsWith('.webp')) {
        alert('この画像は既にWebP形式で最適化されています');
        return;
      }
      
      if (!confirm(`画像「${filename}」をWebP形式に最適化しますか？`)) return;
      
      try {
        const cardType = (byId('card_type').value || 'Pokemon').toLowerCase();
        const currentUrl = currentPreviewUrl();
        
        if (!currentUrl || currentUrl.startsWith('blob:')) {
          alert('最適化可能な画像が見つかりません');
          return;
        }
        
        // 現在表示中の画像を取得
        const img = byId('preview-img');
        if (!img.src || !img.complete) {
          alert('画像の読み込みが完了していません');
          return;
        }
        
        // Canvas で WebP に変換
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // 最大サイズ制限
        const maxWidth = 800;
        const maxHeight = 1200;
        let { width, height } = img;
        
        if (width > maxWidth || height > maxHeight) {
          const ratio = Math.min(maxWidth / width, maxHeight / height);
          width = Math.floor(width * ratio);
          height = Math.floor(height * ratio);
        }
        
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        
        // WebP として書き出し
        const webpDataUrl = canvas.toDataURL('image/webp', 0.85);
        const blob = await (await fetch(webpDataUrl)).blob();
        
        // 新しいファイル名を生成
        const webpFilename = filename.replace(/\.[^.]+$/, '.webp');
        
        // File System API で保存を試行
        if ('showDirectoryPicker' in window) {
          const dirHandle = await window.showDirectoryPicker();
          const assetsHandle = await dirHandle.getDirectoryHandle('assets', { create: true });
          const cardsHandle = await assetsHandle.getDirectoryHandle('cards', { create: true });
          const typeHandle = await cardsHandle.getDirectoryHandle(cardType, { create: true });
          
          const fileHandle = await typeHandle.getFileHandle(webpFilename, { create: true });
          const writable = await fileHandle.createWritable();
          await writable.write(blob);
          await writable.close();
          
          // ファイル名を更新
          byId('image_file').value = webpFilename;
          updateImageActions();
          updatePreview();
          markUnsaved(true);
          
          alert(`画像をWebPに最適化しました: ${filename} → ${webpFilename}\nサイズ: ${(blob.size/1024).toFixed(1)}KB`);
        } else {
          // フォールバック: ダウンロードリンクを作成
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = webpFilename;
          a.style.display = 'none';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          
          alert(`WebP形式でダウンロードしました: ${webpFilename}\n手動でassetsフォルダに移動してください`);
        }
        
      } catch (error) {
        console.error('Failed to optimize image:', error);
        alert('画像の最適化に失敗しました: ' + error.message);
      }
    }
    
    function guessNameFromCard(card){
      const t = (card.card_type||'Pokemon').toLowerCase();
      const extMatch = (card.image_file || '').toLowerCase().match(/\.[^.]+$/);
      const ext = extMatch ? extMatch[0] : '.webp';
      if (t==='energy' && card.energy_type) return `Energy_${card.energy_type}${ext}`;
      if (t==='pokemon' && card.name_en) return card.name_en.replace(/[^A-Za-z0-9]+/g,'_')+ext;
      return '';
    }
    function goNext(){
      if (cards.length === 0) return;
      const nextIdx = (activeIndex + 1) % cards.length;
      activeIndex = nextIdx;
      writeForm(cards[activeIndex]);
      updatePreview();
      renderList();
    }
    function goPrev(){
      if (cards.length === 0) return;
      const prevIdx = (activeIndex - 1 + cards.length) % cards.length;
      activeIndex = prevIdx;
      writeForm(cards[activeIndex]);
      updatePreview();
      renderList();
    }
  </script>
  <!-- Card editor server integration -->
  <script src="./js/card-api.js"></script>
  <script src="./js/card-viewer-integration.js"></script>
</body>
</html>
